/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { ClientRequestArgs } from 'http';
import type { WebSocket, ClientOptions, RawData } from 'ws';
import EventEmitter from 'events';
export type ReconnexT = {
    url: string;
    reconnect?: {
        maxAttempts?: number;
        connectTimeout?: number;
    };
    ping?: {
        data: any;
        interval: number;
    };
    options?: ClientOptions | ClientRequestArgs | undefined;
};
export declare class Reconnex extends EventEmitter {
    #private;
    constructor({ url, ping, reconnect, options }: ReconnexT);
    on<E extends keyof ReconnexEvents>(event: E, listener: ReconnexEvents[E]): this;
    private connect;
    private addWSListeners;
    waitTwitchWSConnected(): Promise<unknown>;
    disconnect: (reason?: string) => void;
    open: () => false | WebSocket | null;
    send: (text: string | Buffer) => Promise<void>;
    json: (data: any) => Promise<void>;
    sendJSONBinary: (data: any) => Promise<void>;
    sendOnConnect: (content?: string) => string[];
    removeSendOnConnect: (content: string) => string[];
    isConnected: () => boolean;
}
export type onTextEvent = (text: string) => void;
export type onMessageEvent = (message: RawData) => void;
export type onCloseEvent = (code: number, reason?: Buffer | string) => void;
export type onOpenEvent = (url: string) => void;
export type onMaxAttemptEvent = () => void;
interface CustomError extends Error {
    code?: string;
}
export type onErrorEvent = (err: CustomError) => void;
export type onSendEvent = (data: string) => void;
export type onRetryEvent = (attempt: number, maxAttempts: number) => void;
export type ReconnexEvents = {
    text: onTextEvent;
    message: onMessageEvent;
    close: onCloseEvent;
    open: onOpenEvent;
    max_attempt: onMaxAttemptEvent;
    error: onErrorEvent;
    send: onSendEvent;
    retry: onRetryEvent;
};
export {};
