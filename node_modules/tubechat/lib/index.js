"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _TubeChat_channels, _TubeChat_intervalChat, _TubeChat_monitor;
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertSymbolCurrencies = exports.TubeChat = void 0;
const stream_1 = require("stream");
const ChatMessages_1 = require("./lib/ChatMessages");
const addBannerToLiveChatCommand_1 = __importDefault(require("./lib/actions/addBannerToLiveChatCommand"));
const addChatItemAction_1 = __importDefault(require("./lib/actions/addChatItemAction"));
const closeLiveChatActionPanelAction_1 = __importDefault(require("./lib/actions/closeLiveChatActionPanelAction"));
const liveChatMembershipItemRenderer_1 = __importDefault(require("./lib/actions/liveChatMembershipItemRenderer"));
const liveChatTickerSponsorItemRenderer_1 = __importDefault(require("./lib/actions/liveChatTickerSponsorItemRenderer"));
const removeBannerForLiveChatCommand_1 = __importDefault(require("./lib/actions/removeBannerForLiveChatCommand"));
const removeChatItemAction_1 = __importDefault(require("./lib/actions/removeChatItemAction"));
const removeChatItemByAuthorAction_1 = __importDefault(require("./lib/actions/removeChatItemByAuthorAction"));
const replaceChatItemAction_1 = __importDefault(require("./lib/actions/replaceChatItemAction"));
const showLiveChatActionPanelAction_1 = __importDefault(require("./lib/actions/showLiveChatActionPanelAction"));
const updateLiveChatPollAction_1 = __importDefault(require("./lib/actions/updateLiveChatPollAction"));
const getYoutubeInitialData_1 = require("./lib/getYoutubeInitialData");
const utils_1 = require("./lib/utils");
const flow_monitor_1 = require("flow-monitor");
// TubeChat (YouTube Chat Capture)
class TubeChat extends stream_1.EventEmitter {
    constructor(config = {}) {
        super();
        _TubeChat_channels.set(this, []);
        _TubeChat_intervalChat.set(this, 1000);
        _TubeChat_monitor.set(this, void 0);
        this.channelList = () => __classPrivateFieldGet(this, _TubeChat_channels, "f");
        __classPrivateFieldSet(this, _TubeChat_intervalChat, config.intervalChat || 1000, "f");
        __classPrivateFieldSet(this, _TubeChat_monitor, (config === null || config === void 0 ? void 0 : config.flowMonitor) || new flow_monitor_1.FlowMonitor(), "f");
        this.checkers();
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    updateVideo(user, videoId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield (0, getYoutubeInitialData_1.getYoutubeInitialData)(videoId);
            if (response.code == 'success') {
                const { clientName, clientVersion, loggedIn, continuation, params, apiKey, } = response;
                this.updateChannelData(user, {
                    videoId,
                    continuationData: {
                        apiKey,
                        clientName,
                        clientVersion,
                        nextPage: continuation
                    },
                });
                this.emit('chat_connected', user, videoId);
            }
            else if (response.code == 'ended_event' || response.code == 'chat_not_found' || response.code == 'error') {
                this.chatDisconnected(user);
            }
        });
    }
    channelUpdate(user, videoId, streamDown = false, platform) {
        return __awaiter(this, void 0, void 0, function* () {
            if (platform == 'youtube') {
                const channelData = __classPrivateFieldGet(this, _TubeChat_channels, "f").find(chn => chn.user == user);
                if (channelData === null || channelData === void 0 ? void 0 : channelData.user) {
                    if (streamDown) {
                        this.chatDisconnected(channelData === null || channelData === void 0 ? void 0 : channelData.user);
                        return;
                    }
                    if (!(channelData === null || channelData === void 0 ? void 0 : channelData.videoId) && videoId) {
                        this.updateVideo(channelData.user, videoId);
                    }
                    else if ((channelData === null || channelData === void 0 ? void 0 : channelData.videoId) && channelData.videoId !== videoId) {
                        this.updateVideo(channelData.user, videoId);
                    }
                }
            }
        });
    }
    checkerLive() {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            (_a = __classPrivateFieldGet(this, _TubeChat_monitor, "f")) === null || _a === void 0 ? void 0 : _a.on('streamUp', (data) => this.channelUpdate(data.channel, data.vodId, false, data.platform));
            (_b = __classPrivateFieldGet(this, _TubeChat_monitor, "f")) === null || _b === void 0 ? void 0 : _b.on('streamDown', (data) => this.channelUpdate(data.channel, data.vodId, true, data.platform));
            (_c = __classPrivateFieldGet(this, _TubeChat_monitor, "f")) === null || _c === void 0 ? void 0 : _c.on('viewerCount', (data) => this.channelUpdate(data.channel, data.vodId, false, data.platform));
            (_d = __classPrivateFieldGet(this, _TubeChat_monitor, "f")) === null || _d === void 0 ? void 0 : _d.start();
        });
    }
    updateChannelData(updateUser, newData) {
        __classPrivateFieldSet(this, _TubeChat_channels, __classPrivateFieldGet(this, _TubeChat_channels, "f").map((channel) => {
            if (channel.user === updateUser) {
                if (newData === null || newData === void 0 ? void 0 : newData.continuationData)
                    channel = Object.assign(Object.assign(Object.assign({}, channel), newData), { continuationData: Object.assign(Object.assign({}, channel === null || channel === void 0 ? void 0 : channel.continuationData), newData === null || newData === void 0 ? void 0 : newData.continuationData) });
            }
            return channel;
        }), "f");
    }
    checkerChat() {
        return __awaiter(this, void 0, void 0, function* () {
            const channels = __classPrivateFieldGet(this, _TubeChat_channels, "f").filter(({ videoId }) => videoId !== null);
            for (const { user, videoId, continuationData, shownFirstMessages } of channels) {
                if (videoId && !continuationData) {
                    const response = yield (0, getYoutubeInitialData_1.getYoutubeInitialData)(videoId);
                    if (response.code == 'success') {
                        const { clientName, clientVersion, loggedIn, continuation, params, apiKey, } = response;
                        this.updateChannelData(user, {
                            continuationData: {
                                apiKey,
                                clientName,
                                clientVersion,
                                nextPage: continuation
                            },
                        });
                    }
                    else if (response.code == 'ended_event' || response.code == 'chat_not_found' || response.code == 'error') {
                        this.chatDisconnected(user);
                    }
                }
                else if (videoId && (continuationData === null || continuationData === void 0 ? void 0 : continuationData.nextPage) && (continuationData === null || continuationData === void 0 ? void 0 : continuationData.apiKey) && (continuationData === null || continuationData === void 0 ? void 0 : continuationData.clientName) && (continuationData === null || continuationData === void 0 ? void 0 : continuationData.clientVersion)) {
                    const chatRes = yield (0, ChatMessages_1.fetchChat)(continuationData.nextPage, continuationData.apiKey, continuationData.clientName, continuationData.clientVersion);
                    const continuation = (0, utils_1.findKey)(chatRes, "continuation");
                    if (chatRes === null || chatRes === void 0 ? void 0 : chatRes.error) {
                        if (chatRes.error.code == 400) {
                            this.chatDisconnected(user);
                        }
                    }
                    else if (!continuation || (chatRes === null || chatRes === void 0 ? void 0 : chatRes.code) == 'ENOTFOUND') {
                        this.chatDisconnected(user);
                    }
                    else {
                        if (shownFirstMessages) {
                            const actions = (0, utils_1.findKey)(chatRes, "actions");
                            if (actions) {
                                actions.map((msg) => {
                                    for (const [key, value] of Object.entries(msg)) {
                                        const val = value;
                                        const actionName = key;
                                        const parser = this.parseChatItem();
                                        const parseChatActionsFn = parser === null || parser === void 0 ? void 0 : parser[actionName];
                                        if (parseChatActionsFn) {
                                            parseChatActionsFn(val, this, user);
                                        }
                                        else {
                                            this.emit("unkown", { key, value, channel: user });
                                        }
                                    }
                                });
                            }
                        }
                        this.updateChannelData(user, {
                            shownFirstMessages: true,
                            continuationData: {
                                nextPage: continuation
                            },
                        });
                    }
                }
            }
            yield (0, utils_1.sleep)(__classPrivateFieldGet(this, _TubeChat_intervalChat, "f") / 2);
            this.checkerChat();
        });
    }
    parseChatItem() {
        const actions = {
            addChatItemAction: addChatItemAction_1.default,
            addBannerToLiveChatCommand: // common message
            addBannerToLiveChatCommand_1.default,
            removeChatItemByAuthorAction: // fixed messages, polls and others
            removeChatItemByAuthorAction_1.default,
            removeBannerForLiveChatCommand: // deleted message
            removeBannerForLiveChatCommand_1.default,
            updateLiveChatPollAction: // when remove live banner
            updateLiveChatPollAction_1.default,
            closeLiveChatActionPanelAction: // loop receiving polls data
            closeLiveChatActionPanelAction_1.default,
            showLiveChatActionPanelAction: //
            showLiveChatActionPanelAction_1.default,
            liveChatMembershipItemRenderer: liveChatMembershipItemRenderer_1.default,
            liveChatTickerSponsorItemRenderer: liveChatTickerSponsorItemRenderer_1.default,
            replaceChatItemAction: replaceChatItemAction_1.default,
            removeChatItemAction: removeChatItemAction_1.default
        };
        return actions;
    }
    chatDisconnected(user) {
        return __awaiter(this, void 0, void 0, function* () {
            const userData = __classPrivateFieldGet(this, _TubeChat_channels, "f").find((chn) => chn.user == user);
            if (userData) {
                this.emit('chat_disconnected', userData === null || userData === void 0 ? void 0 : userData.user, userData === null || userData === void 0 ? void 0 : userData.videoId);
                this.updateChannelData(user, {
                    continuationData: {
                        nextPage: '',
                        apiKey: '',
                        clientName: '',
                        clientVersion: ''
                    },
                    videoId: null,
                    shownFirstMessages: null
                });
            }
        });
    }
    disconnect(user) {
        var _a;
        user = user.replace('@', '');
        this.chatDisconnected(user);
        (_a = __classPrivateFieldGet(this, _TubeChat_monitor, "f")) === null || _a === void 0 ? void 0 : _a.disconnect(user, 'youtube');
    }
    checkers() {
        this.checkerLive();
        this.checkerChat();
    }
    connect(channel) {
        var _a;
        if (channel) {
            const alreadyAdded = __classPrivateFieldGet(this, _TubeChat_channels, "f").find(chn => chn.user == channel);
            if (alreadyAdded)
                return;
            const user = channel.replace('@', '');
            __classPrivateFieldGet(this, _TubeChat_channels, "f").push({
                user,
                videoId: null,
                shownFirstMessages: null
            });
            (_a = __classPrivateFieldGet(this, _TubeChat_monitor, "f")) === null || _a === void 0 ? void 0 : _a.connect(user, 'youtube');
        }
    }
}
exports.TubeChat = TubeChat;
_TubeChat_channels = new WeakMap(), _TubeChat_intervalChat = new WeakMap(), _TubeChat_monitor = new WeakMap();
function convertSymbolCurrencies(stringValue, customFormats) {
    var _a;
    const currencyFormats = customFormats || {
        "$": "usd",
        "£": "gbp",
        "¥": "jpy",
        "jp¥": "jpy",
        "฿": "thb",
        "₩": "krw",
        "₪": "ils",
        "€": "eur",
        "₱": "php",
        "₹": "inr",
        "A$": "aud",
        "CA$": "cad",
        "HK$": "hkd",
        "MX$": "mxn",
        "NT$": "twd",
        "NZ$": "nzd",
        "R$": "brl",
        "₽": "rub",
        "SEK": "sek",
        "ARS": "ars"
    };
    let symbolStr = "", value = 0;
    for (const symbol in currencyFormats) {
        symbolStr = symbol;
        if (stringValue.startsWith(symbol)) {
            value = Number(stringValue.split(symbol)[1]);
            return { symbol, currency: currencyFormats[symbol], value };
        }
    }
    const currency = stringValue.split(' ')[0].split(' ')[0];
    // @ts-ignore
    return { symbol: currency, currency: currency.toLowerCase(), value: value == 0 ? Number((stringValue === null || stringValue === void 0 ? void 0 : stringValue.split) && ((_a = stringValue.split(' ').pop().split(' ')) === null || _a === void 0 ? void 0 : _a.pop())) : value };
}
exports.convertSymbolCurrencies = convertSymbolCurrencies;
