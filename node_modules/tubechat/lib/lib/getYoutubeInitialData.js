"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getYoutubeInitialData = void 0;
const utils_1 = require("./utils");
function getYoutubeInitialData(videoId, cookies = "") {
    var _a, _b, _c, _d;
    return __awaiter(this, void 0, void 0, function* () {
        let error = 0;
        let messageError = "";
        try {
            const headers = {
                'Accept-Language': 'pt-BR',
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 OPR/100.0.0.0',
                "Cookies": cookies
            };
            const responseData = yield fetch(`https://www.youtube.com/live_chat?is_popout=1&v=${videoId}`, {
                headers
            });
            const responseText = yield responseData.text();
            if (responseText.includes("search-button")) {
                error = 1;
            }
            const apiKey = (0, utils_1.getStr)(responseText, 'INNERTUBE_API_KEY":"', '"');
            const ytInitialDataText = (0, utils_1.getStr)(responseText, `window["ytInitialData"] = `, `;</script>`);
            const ytInitialData = JSON.parse(ytInitialDataText);
            const endedEvent = ((_d = (_c = (_b = (_a = ytInitialData.contents) === null || _a === void 0 ? void 0 : _a.messageRenderer) === null || _b === void 0 ? void 0 : _b.text) === null || _c === void 0 ? void 0 : _c.runs[0]) === null || _d === void 0 ? void 0 : _d.text) || "";
            if (endedEvent) {
                error = 2;
                messageError = endedEvent;
            }
            const [clientName, clientVersion] = ytInitialData.responseContext.serviceTrackingParams[0].params;
            const [loggedIn] = ytInitialData.responseContext.serviceTrackingParams[1].params;
            const [_chatMain, chatAll] = ytInitialData.contents.liveChatRenderer.header.liveChatHeaderRenderer.viewSelector.sortFilterSubMenuRenderer.subMenuItems;
            const continuation = chatAll.continuation.reloadContinuationData.continuation;
            const sendLiveChatMessageEndpoint = (0, utils_1.findKey)(ytInitialData, "sendLiveChatMessageEndpoint");
            return {
                code: "success",
                clientName: clientName.value,
                clientVersion: clientVersion.value,
                loggedIn: loggedIn.value || "0",
                continuation: continuation,
                params: (sendLiveChatMessageEndpoint === null || sendLiveChatMessageEndpoint === void 0 ? void 0 : sendLiveChatMessageEndpoint.params) || "",
                apiKey
            };
        }
        catch (err) {
            if (error == 0) {
                return {
                    code: "error",
                    message: "Unknown fetch error"
                };
            }
            if (error = 1) {
                return {
                    code: "chat_not_found",
                    message: "Cannot find stream chat"
                };
            }
            if (error = 2) {
                return {
                    code: "ended_event",
                    message: messageError
                };
            }
        }
        return {
            code: "error",
            message: "Unknown error"
        };
    });
}
exports.getYoutubeInitialData = getYoutubeInitialData;
function fetchVideo(userId) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        let fetchVideoData;
        try {
            fetchVideoData = yield fetch(`https://www.youtube.com/@${userId}/live`, { cache: "no-cache" });
        }
        catch (e) {
            return {
                error: 'fetch Error',
                code: 'network_error'
            };
        }
        const videoResponseRaw = yield fetchVideoData.text();
        let ytInitialPlayerResponse;
        const videoId = (0, utils_1.getStr)(videoResponseRaw, 'https://www.youtube.com/embed/', '">');
        try {
            ytInitialPlayerResponse = JSON.parse((0, utils_1.getStr)(videoResponseRaw, `var ytInitialPlayerResponse = `, ";</script>"));
        }
        catch (e) {
            try {
                ytInitialPlayerResponse = JSON.parse((0, utils_1.getStr)(videoResponseRaw, `var ytInitialPlayerResponse = `, ";var head"));
            }
            catch (_d) {
                return {
                    liveIn: false,
                    videoId,
                    status: 'ERROR',
                    reason: 'Channel is Offline'
                };
            }
        }
        const ytInitialData = JSON.parse((0, utils_1.getStr)(videoResponseRaw, 'var ytInitialData = ', ';</script>'));
        const { status, reason, messages } = ytInitialPlayerResponse.playabilityStatus;
        if (reason || messages) {
            return ytInitialPlayerResponse.playabilityStatus;
        }
        const storyboardSpec = (_b = (_a = ytInitialPlayerResponse === null || ytInitialPlayerResponse === void 0 ? void 0 : ytInitialPlayerResponse.storyboards) === null || _a === void 0 ? void 0 : _a.playerStoryboardSpecRenderer) === null || _b === void 0 ? void 0 : _b.spec;
        const duration = (_c = ytInitialPlayerResponse === null || ytInitialPlayerResponse === void 0 ? void 0 : ytInitialPlayerResponse.videoDetails) === null || _c === void 0 ? void 0 : _c.lengthSeconds;
        const { title, shortDescription, channelId, thumbnail: { thumbnails }, viewCount, author, lengthSeconds, isLiveContent, isLive, isPrivate, latencyClass, keywords, isLowLatencyLiveStream } = ytInitialPlayerResponse.videoDetails;
        const { uploadDate, ownerProfileUrl, isUnlisted, category: categoryName, publishDate, liveBroadcastDetails, } = ytInitialPlayerResponse.microformat.playerMicroformatRenderer;
        const { formats, adaptiveFormats, expiresInSeconds, dashManifestUrl, hlsManifestUrl } = ytInitialPlayerResponse.streamingData;
        const category_richMetadataRenderer = (0, utils_1.findKey)(ytInitialData, 'richMetadataRenderer');
        const category = {
            id: '0',
            name: categoryName,
            image: 'https://yt3.ggpht.com/QqoTjrpKRDMfGFPYpgIaTmHkbQ6Lk-brN77OxCYwl0jTtluavivXDdd4lR2wQsr_hcIggw=s136-w136-h136-c-k-c0x00ffffff-no-nd-rj'
        };
        const viewers = Number((0, utils_1.findKey)(ytInitialData, 'originalViewCount'));
        if (category_richMetadataRenderer) {
            const categoryThumbs = (0, utils_1.findKey)(category_richMetadataRenderer, 'thumbnails');
            const categoryThumbnail = categoryThumbs.pop().url;
            const categoryName = (0, utils_1.findKey)((0, utils_1.findKey)(category_richMetadataRenderer, 'title'), 'simpleText').concat(' ') + (0, utils_1.findKey)((0, utils_1.findKey)(category_richMetadataRenderer, 'subtitle'), 'simpleText');
            if (categoryName)
                category.name = categoryName;
            if (categoryThumbnail)
                category.image = categoryThumbnail;
        }
        const live = Object.assign(Object.assign({}, liveBroadcastDetails), { viewers,
            expiresInSeconds,
            dashManifestUrl,
            hlsManifestUrl,
            latencyClass,
            isLowLatencyLiveStream });
        const baseScript = `https://www.youtube.com/s/player/${(0, utils_1.getStr)(videoResponseRaw, '/s/player/', '"')}`;
        const userIdYT = ownerProfileUrl.split("/").pop();
        return Object.assign(Object.assign({ status,
            channelId,
            userIdYT,
            author,
            ownerProfileUrl,
            isLive,
            isLiveContent,
            isUnlisted,
            isPrivate,
            videoId, duration: Number(lengthSeconds), title, views: Number(viewCount), category,
            keywords,
            thumbnails,
            shortDescription,
            publishDate,
            uploadDate }, (isLive && { live })), { baseScript,
            formats,
            adaptiveFormats });
    });
}
exports.default = fetchVideo;
