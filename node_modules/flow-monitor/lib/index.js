"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _FlowMonitor_lock, _FlowMonitor_liveData, _FlowMonitor_connectedChannels, _FlowMonitor_youtubeChannelsChecker, _FlowMonitor_youtubeIntervalChecker, _FlowMonitor_twitchHeaders, _FlowMonitor_youtubehHeaders, _FlowMonitor_youtubeCheckerConnected, _FlowMonitor_twitchWSConnected, _FlowMonitor_startedChecker, _FlowMonitor_zTwSocket;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlowMonitor = void 0;
const async_lock_1 = __importDefault(require("async-lock"));
const events_1 = require("events");
const reconnex_1 = require("reconnex");
const fetchTwitchData_1 = require("./fetchTwitchData");
const twitchws_1 = require("./twitchws");
const utils_1 = require("./utils");
const helpers_1 = __importDefault(require("./youtube/helpers"));
class FlowMonitor extends events_1.EventEmitter {
    constructor({ youtube, twitch } = {}) {
        super();
        _FlowMonitor_lock.set(this, new async_lock_1.default());
        _FlowMonitor_liveData.set(this, {});
        _FlowMonitor_connectedChannels.set(this, []);
        _FlowMonitor_youtubeChannelsChecker.set(this, []);
        _FlowMonitor_youtubeIntervalChecker.set(this, 5 * 1000);
        _FlowMonitor_twitchHeaders.set(this, {});
        _FlowMonitor_youtubehHeaders.set(this, {});
        _FlowMonitor_youtubeCheckerConnected.set(this, false);
        _FlowMonitor_twitchWSConnected.set(this, false);
        _FlowMonitor_startedChecker.set(this, false);
        _FlowMonitor_zTwSocket.set(this, new reconnex_1.Reconnex({
            url: twitchws_1.pubsubWSURL,
            ping: {
                data: '{"type":"PING"}',
                interval: 3 * 60 * 1000
            },
            reconnect: {
                maxAttempts: -1
            }
        }));
        __classPrivateFieldSet(this, _FlowMonitor_youtubeIntervalChecker, (youtube === null || youtube === void 0 ? void 0 : youtube.intervalChecker) || 5 * 1000, "f");
        __classPrivateFieldSet(this, _FlowMonitor_twitchHeaders, twitch === null || twitch === void 0 ? void 0 : twitch.headers, "f");
        __classPrivateFieldSet(this, _FlowMonitor_youtubehHeaders, youtube === null || youtube === void 0 ? void 0 : youtube.headers, "f");
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    setCheckerConnected(channel, connected, platform) {
        __classPrivateFieldGet(this, _FlowMonitor_lock, "f").acquire('lm', () => {
            __classPrivateFieldSet(this, _FlowMonitor_connectedChannels, __classPrivateFieldGet(this, _FlowMonitor_connectedChannels, "f").filter(chn => {
                if (chn.channel == channel && chn.platform == platform) {
                    chn.checkerConnected = connected;
                }
                return chn;
            }), "f");
        });
    }
    connect(channel, platform) {
        const channelIsConnected = __classPrivateFieldGet(this, _FlowMonitor_connectedChannels, "f").find(chn => chn.channel == channel && chn.platform == platform);
        if (!channelIsConnected) {
            this.emit('newChannel', { name: channel, platform });
            __classPrivateFieldGet(this, _FlowMonitor_connectedChannels, "f").push({
                channel: formatChannelName(channel),
                platform
            });
        }
    }
    livedata(channel, platform) {
        return __classPrivateFieldGet(this, _FlowMonitor_liveData, "f")[`${channel}.${platform}`];
    }
    disconnect(channel, platform) {
        channel = formatChannelName(channel);
        const channelIsConnected = __classPrivateFieldGet(this, _FlowMonitor_connectedChannels, "f").find(chn => chn.channel == channel && chn.platform == platform);
        if (channelIsConnected) {
            __classPrivateFieldGet(this, _FlowMonitor_lock, "f").acquire('lm', () => {
                __classPrivateFieldSet(this, _FlowMonitor_connectedChannels, __classPrivateFieldGet(this, _FlowMonitor_connectedChannels, "f").filter(chn => chn.channel !== channel && chn.platform !== platform), "f");
                if (channelIsConnected.checkerConnected) {
                    if (channelIsConnected.platform == 'twitch') {
                        this.twitchSubUnsubWSEvents({
                            channel: channel,
                            platform,
                            event: 'UNLISTEN'
                        });
                    }
                    else if (channelIsConnected.platform == 'youtube') {
                        this.emit('disconnectChannel', {
                            name: channelIsConnected.channel,
                            platform: channelIsConnected.platform
                        });
                        __classPrivateFieldSet(this, _FlowMonitor_youtubeChannelsChecker, __classPrivateFieldGet(this, _FlowMonitor_youtubeChannelsChecker, "f").filter(({ user }) => user !== channelIsConnected.channel), "f");
                        delete __classPrivateFieldGet(this, _FlowMonitor_liveData, "f")[`${channelIsConnected.channel}.${channelIsConnected.platform}`];
                    }
                }
            });
        }
    }
    emitLiveData({ category, channel, platform, started_at, thumbnail, title, viewers, vodId, event, m3u8Url, id, userId }) {
        this.emit(event, {
            category: {
                id: category === null || category === void 0 ? void 0 : category.id,
                image: category === null || category === void 0 ? void 0 : category.image,
                name: category === null || category === void 0 ? void 0 : category.name
            },
            channel,
            userId,
            platform,
            started_at: started_at,
            thumbnail: thumbnail,
            title,
            viewers: viewers,
            vodId: vodId,
            m3u8Url,
            id
        });
    }
    connectTwWebsocket() {
        return __awaiter(this, void 0, void 0, function* () {
            __classPrivateFieldSet(this, _FlowMonitor_twitchWSConnected, true, "f");
            if (!__classPrivateFieldGet(this, _FlowMonitor_zTwSocket, "f").isConnected())
                __classPrivateFieldGet(this, _FlowMonitor_zTwSocket, "f").open();
        });
    }
    start() {
        if (__classPrivateFieldGet(this, _FlowMonitor_startedChecker, "f"))
            return;
        __classPrivateFieldSet(this, _FlowMonitor_startedChecker, true, "f");
        this.emit('start');
        this.addTwitchListeners();
        let cInterval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            const channels = __classPrivateFieldGet(this, _FlowMonitor_connectedChannels, "f").filter(chn => !chn.checkerConnected);
            channels.forEach(({ channel, platform, checkerConnected }) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                if (platform == 'twitch') {
                    if (!((_a = __classPrivateFieldGet(this, _FlowMonitor_zTwSocket, "f")) === null || _a === void 0 ? void 0 : _a.isConnected())) {
                        this.connectTwWebsocket();
                    }
                    if (!checkerConnected) {
                        this.setCheckerConnected(channel, true, platform);
                        (_b = __classPrivateFieldGet(this, _FlowMonitor_zTwSocket, "f")) === null || _b === void 0 ? void 0 : _b.waitTwitchWSConnected().then(() => {
                            this.twitchSubUnsubWSEvents({
                                channel: channel,
                                platform: platform,
                                event: 'LISTEN'
                            });
                        });
                    }
                }
                else if (platform == 'youtube') {
                    if (!__classPrivateFieldGet(this, _FlowMonitor_youtubeCheckerConnected, "f")) {
                        __classPrivateFieldSet(this, _FlowMonitor_youtubeCheckerConnected, true, "f");
                        this.youtubeChecker();
                    }
                    if (!checkerConnected) {
                        this.setCheckerConnected(channel, true, platform);
                        const ytCheckerConnected = __classPrivateFieldGet(this, _FlowMonitor_youtubeChannelsChecker, "f").find(({ user }) => user == channel);
                        if (!ytCheckerConnected) {
                            __classPrivateFieldGet(this, _FlowMonitor_youtubeChannelsChecker, "f").push({
                                user: channel,
                                live: false
                            });
                        }
                    }
                }
            }));
            if (!__classPrivateFieldGet(this, _FlowMonitor_startedChecker, "f"))
                clearInterval(cInterval);
        }), 100);
    }
    close() {
        var _a;
        this.emit('close');
        __classPrivateFieldSet(this, _FlowMonitor_startedChecker, false, "f");
        __classPrivateFieldSet(this, _FlowMonitor_liveData, {}, "f");
        __classPrivateFieldSet(this, _FlowMonitor_twitchWSConnected, false, "f");
        (_a = __classPrivateFieldGet(this, _FlowMonitor_zTwSocket, "f")) === null || _a === void 0 ? void 0 : _a.disconnect();
        __classPrivateFieldSet(this, _FlowMonitor_youtubeChannelsChecker, [], "f");
    }
    twitchSubUnsubWSEvents({ channel, platform, event, streamDown }) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
            const { login, categoryId, categoryImage, categoryName, started_at, streamId, title, userId, viewersCount, thumbnail, m3u8Url, code, error, message, status } = yield (0, fetchTwitchData_1.fetchTwitchData)(channel, __classPrivateFieldGet(this, _FlowMonitor_twitchHeaders, "f"));
            if (error) {
                this.emit('twitchError', error, status, message);
            }
            if (login) {
                if (!streamDown) {
                    if (event == 'LISTEN') {
                        (_a = __classPrivateFieldGet(this, _FlowMonitor_zTwSocket, "f")) === null || _a === void 0 ? void 0 : _a.sendOnConnect(twitchws_1.payloads.gameBroadcaster(String(userId), event));
                        (_b = __classPrivateFieldGet(this, _FlowMonitor_zTwSocket, "f")) === null || _b === void 0 ? void 0 : _b.sendOnConnect(twitchws_1.payloads.videoPlayBack(String(userId), event));
                    }
                    else {
                        (_c = __classPrivateFieldGet(this, _FlowMonitor_zTwSocket, "f")) === null || _c === void 0 ? void 0 : _c.send(twitchws_1.payloads.gameBroadcaster(String(userId), event));
                        (_d = __classPrivateFieldGet(this, _FlowMonitor_zTwSocket, "f")) === null || _d === void 0 ? void 0 : _d.send(twitchws_1.payloads.videoPlayBack(String(userId), event));
                        (_e = __classPrivateFieldGet(this, _FlowMonitor_zTwSocket, "f")) === null || _e === void 0 ? void 0 : _e.removeSendOnConnect(twitchws_1.payloads.gameBroadcaster(String(userId), 'LISTEN'));
                        (_f = __classPrivateFieldGet(this, _FlowMonitor_zTwSocket, "f")) === null || _f === void 0 ? void 0 : _f.removeSendOnConnect(twitchws_1.payloads.videoPlayBack(String(userId), 'LISTEN'));
                    }
                }
                const channelData = {
                    category: {
                        id: String(categoryId),
                        image: categoryImage,
                        name: categoryName
                    },
                    started_at,
                    vodId: String(streamId),
                    title: String(title),
                    viewers: viewersCount || 0,
                    channel,
                    userId: String(userId || channel),
                    platform,
                    thumbnail,
                    m3u8Url,
                    id: generateUUID()
                };
                Object.assign(__classPrivateFieldGet(this, _FlowMonitor_liveData, "f"), { [`${channel}.${platform}`]: channelData });
                __classPrivateFieldGet(this, _FlowMonitor_lock, "f").acquire('lm', () => {
                    __classPrivateFieldSet(this, _FlowMonitor_connectedChannels, __classPrivateFieldGet(this, _FlowMonitor_connectedChannels, "f").map(chn => {
                        if (chn.channel == channel) {
                            chn.userId = String(userId);
                        }
                        return chn;
                    }), "f");
                });
                if (streamId && streamId > 0 && event !== 'UNLISTEN')
                    this.emitLiveData(Object.assign({ event: 'streamUp' }, channelData));
                if (event == 'UNLISTEN') {
                    delete __classPrivateFieldGet(this, _FlowMonitor_liveData, "f")[`${channel}.${platform}`];
                }
                if (streamDown) {
                    this.emitLiveData(Object.assign({ event: 'streamDown' }, channelData));
                    return;
                }
                if (event == 'UNLISTEN') {
                    this.emit('disconnectChannel', {
                        name: login,
                        platform: 'twitch'
                    });
                }
            }
        });
    }
    getTwChannelById(userId) {
        return __classPrivateFieldGet(this, _FlowMonitor_connectedChannels, "f").find(chn => chn.userId === userId);
    }
    addTwitchListeners() {
        __classPrivateFieldGet(this, _FlowMonitor_zTwSocket, "f").on('text', (text) => {
            const wsMessage = JSON.parse(text.toString()) || {};
            if (wsMessage.type === "MESSAGE") {
                const { topic, message } = wsMessage.data;
                const [payload, userId] = topic.split(".");
                const channel = this.getTwChannelById(userId);
                const userLiveData = __classPrivateFieldGet(this, _FlowMonitor_liveData, "f")[`${channel === null || channel === void 0 ? void 0 : channel.channel}.${channel === null || channel === void 0 ? void 0 : channel.platform}`];
                if (payload == "video-playback-by-id") {
                    const status = JSON.parse(message);
                    if (status.type == 'stream-up') {
                        let timeoutStreamId = setTimeout(() => {
                            clearInterval(waitForStreamId);
                        }, 10 * 1000);
                        let waitForStreamId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                            const { login, categoryId, categoryImage, categoryName, started_at, streamId, title, viewersCount, thumbnail, m3u8Url } = yield (0, fetchTwitchData_1.fetchTwitchData)(String(channel === null || channel === void 0 ? void 0 : channel.channel));
                            if (started_at && m3u8Url) {
                                clearTimeout(timeoutStreamId);
                                clearInterval(waitForStreamId);
                                const channelData = {
                                    category: {
                                        id: String(categoryId),
                                        image: categoryImage,
                                        name: categoryName
                                    },
                                    started_at,
                                    vodId: String(streamId),
                                    title: String(title),
                                    viewers: viewersCount || 0,
                                    channel: login,
                                    userId: String(userId || channel),
                                    platform: channel === null || channel === void 0 ? void 0 : channel.platform,
                                    thumbnail,
                                    m3u8Url,
                                    id: generateUUID()
                                };
                                Object.assign(__classPrivateFieldGet(this, _FlowMonitor_liveData, "f"), { [`${login}.${channel === null || channel === void 0 ? void 0 : channel.platform}`]: channelData });
                                this.emitLiveData(Object.assign({ event: 'streamUp' }, channelData));
                            }
                        }), 1000);
                    }
                    if (status.type == 'stream-down' && channel) {
                        this.twitchSubUnsubWSEvents({
                            channel: channel.channel,
                            platform: channel.platform,
                            event: 'UNLISTEN',
                            streamDown: true
                        });
                    }
                    else if (status.type == 'viewcount' && channel && userLiveData) {
                        const { viewers, channel: channelName } = __classPrivateFieldGet(this, _FlowMonitor_liveData, "f")[`${channel.channel}.${channel.platform}`];
                        if (viewers !== status.viewers) {
                            Object.assign(__classPrivateFieldGet(this, _FlowMonitor_liveData, "f"), {
                                [`${channelName}.${channel.platform}`]: Object.assign(Object.assign({}, __classPrivateFieldGet(this, _FlowMonitor_liveData, "f")[`${channel.channel}.${channel.platform}`]), { viewers: status.viewers })
                            });
                            this.emitLiveData(Object.assign({ event: 'viewerCount' }, __classPrivateFieldGet(this, _FlowMonitor_liveData, "f")[`${channel.channel}.${channel.platform}`]));
                        }
                    }
                }
                else if (payload == 'broadcast-settings-update' && channel && userLiveData) {
                    const { channel: channelName, game, game_id, old_game, old_status, status } = JSON.parse(message);
                    if (game !== old_game) {
                        Object.assign(__classPrivateFieldGet(this, _FlowMonitor_liveData, "f"), {
                            [`${channelName}.${channel.platform}`]: Object.assign(Object.assign({}, __classPrivateFieldGet(this, _FlowMonitor_liveData, "f")[`${channel.channel}.${channel.platform}`]), { category: {
                                    id: String(game_id),
                                    image: `https://static-cdn.jtvnw.net/ttv-boxart/${game_id}-144x192.jpg`,
                                    name: game
                                } })
                        });
                        this.emitLiveData(Object.assign({ event: 'category' }, __classPrivateFieldGet(this, _FlowMonitor_liveData, "f")[`${channelName}.${channel.platform}`]));
                    }
                    if (status !== old_status) {
                        Object.assign(__classPrivateFieldGet(this, _FlowMonitor_liveData, "f"), {
                            [`${channelName}.${channel.platform}`]: Object.assign(Object.assign({}, __classPrivateFieldGet(this, _FlowMonitor_liveData, "f")[`${channel.channel}.${channel.platform}`]), { title: status })
                        });
                        this.emitLiveData(Object.assign({ event: 'title' }, __classPrivateFieldGet(this, _FlowMonitor_liveData, "f")[`${channelName}.${channel.platform}`]));
                    }
                }
            }
        });
    }
    youtubeChecker() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const channel of __classPrivateFieldGet(this, _FlowMonitor_youtubeChannelsChecker, "f")) {
                if (channel.live) {
                    const { reason, status, title, category, live, videoId, error, code } = yield (0, helpers_1.default)(channel.user, __classPrivateFieldGet(this, _FlowMonitor_youtubehHeaders, "f"));
                    if (!code || code !== 'network_error') {
                        const currentData = __classPrivateFieldGet(this, _FlowMonitor_liveData, "f")[`${channel.user}.youtube`];
                        if (reason || status == 'ERROR' || (videoId && videoId !== currentData.vodId)) {
                            this.emitLiveData(Object.assign({ event: 'streamDown' }, currentData));
                            delete __classPrivateFieldGet(this, _FlowMonitor_liveData, "f")[`${channel.user}.youtube`];
                            __classPrivateFieldGet(this, _FlowMonitor_lock, "f").acquire('lm', () => {
                                __classPrivateFieldSet(this, _FlowMonitor_youtubeChannelsChecker, __classPrivateFieldGet(this, _FlowMonitor_youtubeChannelsChecker, "f").filter((chn) => {
                                    if (chn.user == chn.user) {
                                        chn.live = false;
                                    }
                                    return chn;
                                }), "f");
                            });
                        }
                        else {
                            if ((live === null || live === void 0 ? void 0 : live.viewers) && currentData.viewers !== live.viewers) {
                                const channelData = Object.assign(Object.assign({}, currentData), { viewers: live.viewers });
                                Object.assign(__classPrivateFieldGet(this, _FlowMonitor_liveData, "f"), { [`${channel.user}.youtube`]: channelData });
                                this.emitLiveData(Object.assign({ event: 'viewerCount' }, channelData));
                            }
                            else if (title && title !== currentData.title) {
                                const channelData = Object.assign(Object.assign({}, currentData), { title });
                                Object.assign(__classPrivateFieldGet(this, _FlowMonitor_liveData, "f"), { [`${channel.user}.youtube`]: channelData });
                                this.emitLiveData(Object.assign({ event: 'title' }, channelData));
                            }
                            else if ((category === null || category === void 0 ? void 0 : category.name) && category.name !== currentData.category.name) {
                                const channelData = Object.assign(Object.assign({}, currentData), { category });
                                Object.assign(__classPrivateFieldGet(this, _FlowMonitor_liveData, "f"), { [`${channel.user}.youtube`]: channelData });
                                this.emitLiveData(Object.assign({ event: 'category' }, channelData));
                            }
                        }
                    }
                }
                else {
                    const { category, live, title, reason, status, videoId, error, code, channelId } = yield (0, helpers_1.default)(channel.user);
                    if (!code || code !== 'network_error') {
                        if ((live === null || live === void 0 ? void 0 : live.isLiveNow) && !reason && status !== 'ERROR') {
                            const channelData = {
                                category,
                                started_at: String(live === null || live === void 0 ? void 0 : live.startTimestamp),
                                vodId: videoId,
                                title,
                                viewers: (live === null || live === void 0 ? void 0 : live.viewers) || 0,
                                channel: channel.user,
                                userId: channelId,
                                platform: 'youtube',
                                thumbnail: `https://i.ytimg.com/vi/${videoId}/maxresdefault.jpg`,
                                m3u8Url: `${live === null || live === void 0 ? void 0 : live.hlsManifestUrl}`,
                                id: generateUUID()
                            };
                            Object.assign(__classPrivateFieldGet(this, _FlowMonitor_liveData, "f"), { [`${channel.user}.youtube`]: channelData });
                            this.emitLiveData(Object.assign({ event: 'streamUp' }, channelData));
                            __classPrivateFieldGet(this, _FlowMonitor_lock, "f").acquire('lm', () => {
                                __classPrivateFieldSet(this, _FlowMonitor_youtubeChannelsChecker, __classPrivateFieldGet(this, _FlowMonitor_youtubeChannelsChecker, "f").filter(chn => {
                                    if (chn.user == channel.user) {
                                        chn.live = true;
                                    }
                                    return chn;
                                }), "f");
                            });
                        }
                    }
                }
            }
            yield (0, utils_1.sleep)(__classPrivateFieldGet(this, _FlowMonitor_youtubeIntervalChecker, "f"));
            if (!__classPrivateFieldGet(this, _FlowMonitor_youtubeCheckerConnected, "f"))
                return;
            this.youtubeChecker();
        });
    }
}
exports.FlowMonitor = FlowMonitor;
_FlowMonitor_lock = new WeakMap(), _FlowMonitor_liveData = new WeakMap(), _FlowMonitor_connectedChannels = new WeakMap(), _FlowMonitor_youtubeChannelsChecker = new WeakMap(), _FlowMonitor_youtubeIntervalChecker = new WeakMap(), _FlowMonitor_twitchHeaders = new WeakMap(), _FlowMonitor_youtubehHeaders = new WeakMap(), _FlowMonitor_youtubeCheckerConnected = new WeakMap(), _FlowMonitor_twitchWSConnected = new WeakMap(), _FlowMonitor_startedChecker = new WeakMap(), _FlowMonitor_zTwSocket = new WeakMap();
function formatChannelName(name) {
    return name.replace('@', '');
}
function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}
